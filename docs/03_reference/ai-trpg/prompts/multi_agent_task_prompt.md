# 多 Agent 跑团系统 · Codex 任务分配与项目分步提示词

## 使用说明
本文件为 **直接投喂给 Codex 的单文件提示词**。  
目的：让 Codex 自动完成 **多 Agent 分工设计** 与 **项目任务分步规划**，以避免上下文信息交叉导致的 token 爆炸。

---

## Codex 角色设定
你是 Codex（资深软件架构师 + n8n 自动化工程师 + 多 Agent 编排设计师）。

你的目标是：  
为一个「AI 跑团叙事 + 工具结算（读写文档）」系统，设计一套 **低 token 成本的多 Agent 架构**，并输出 **可直接实施的项目任务分步计划**。

---

## 一、已知背景与硬约束（必须遵守）

### 1. 系统目标
- AI 负责叙事与下达结算指令（tool_call）
- 所有数值与状态仅存在于文档存储中
- AI 不读取、不缓存、不推断文档数据
- n8n 负责编排、路由与一次性工具调用
- 工具负责读 → 算 → 写 → 记日志

### 2. 低 token 设计原则
- 不保留历史叙事上下文
- 已发生信息必须可被压缩/覆盖
- 场景、人物、事件均通过 ID + 状态码引用
- 每个 Session 结束必须生成结构化 summary

### 3. 工具调用约束
- 工具调用使用严格 JSON
- 每次对话最多一次 tool_call
- 工具白名单化、参数校验、幂等、防重复

### 4. 已存在工具示例
`player_hp_reduce`
- 输入：campaign_id / player_id / amount / reason / source / session_id
- 工具从文档读取 HP，写回并返回 hp_before / hp_after / log_id

### 5. AI 输出协议（不可破坏）
```json
{
  "say": "...",
  "tool_call": {
    "name": "player_hp_reduce",
    "arguments": { "...": "..." }
  }
}
```

---

## 二、你的任务（必须完成）

### A. 多 Agent 架构设计（高层）
- 设计多个 agent 的分工方案
- 目标：降低 token 爆炸与信息交叉
- 要求：
  - 每个 agent 只接收“最小输入闭包”
  - agent 间只通过短 JSON / 枚举 / ID 通信
  - 明确哪些 agent 是无状态（stateless），哪些是有状态（stateful）
  - 明确 agent 与 n8n / 工具 / 文档的交互边界

### B. 项目任务分步（可执行）
- 按里程碑拆分：
  - M0：最小闭环
  - M1：多 Agent 上线
  - M2：压缩 / 总结机制
  - M3：工具扩展与稳定性
- 每个里程碑需包含：
  - 目标
  - 交付物
  - 验收标准（Definition of Done）
  - 风险点与缓解策略

### C. 任务分配建议
- 将任务分配到不同 agent
- 不强制使用固定命名，你可以自行命名 agent
- 明确每个 agent 的：
  - 职责边界
  - 输入 schema
  - 输出 schema
  - 是否允许调用工具

---

## 三、输出格式（严格）

### 1. 总览表（1 页以内）
- Agent 名称
- 核心职责
- 输入（最小闭包）
- 输出
- 状态属性（无状态 / 有状态）

### 2. 架构描述
- 描述 agent 间如何协作
- 描述 n8n 在其中的路由与编排角色
- 描述状态如何被压缩、覆盖、写回
- 文本长度控制在 **400 行以内**

### 3. 里程碑与任务清单
- 使用编号清单
- 每个任务必须是可实施的工程任务
- 明确 DoD（完成判定）

### 4. 下一步建议
- 最多 10 条
- 用于指导后续扩展或优化

---

## 四、关键限制（必须遵守）
- 禁止建议把完整叙事历史塞回上下文
- 禁止让 AI 直接读取文档存储
- 禁止 agent 之间共享长文本上下文
- 禁止模糊职责边界
- 必须把 Session Summary 作为系统内置步骤，而不是可选项

---

## 五、质量要求
- 输出必须可直接落地于 n8n + 工具服务 / 子工作流
- 必须考虑失败路径（工具失败、模型输出不合规、重复调用、并发写）
- 必须以“结构化状态 + 压缩”为核心设计思想

---

开始输出。
