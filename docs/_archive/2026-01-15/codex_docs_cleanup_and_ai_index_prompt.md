# Codex 一次性任务：整理 docs 旧文档并生成新的代码规范索引（AI_INDEX）

> 目标：在不大改代码的前提下，把 `docs/` 目录内的旧文档“整理归档 + 去重 + 建立索引”，并生成一份**新**的“代码规范索引/开发约束索引”，放到合适路径，供后续每次开发任务引用。  
> 风格：务实、可执行、可长期维护。  
> 注意：此任务主要产出文档与索引，不要求重构业务代码；只允许做与文档一致性/自动化门禁相关的最小辅助脚本（如需要）。

---

## 0. 工作边界（必须遵守）

1. **不要做大范围代码改动**：除非为“文档门禁/漂移检测”增加极小脚本或 CI 配置，且改动范围可控。
2. **不要删掉历史信息**：旧文档允许移动/重命名/归档，但必须保留可追溯性（例如保留原文件名映射或在索引中记录）。
3. **不要发明新架构**：新规范必须以当前项目的真实代码、真实目录结构、以及现有 docs 内容为依据。
4. **规范要可维护**：必须“结构化、可定位、可验证”。避免散文式长篇教程。

---

## 1. 你需要读取与分析的输入

### 1.1 仓库内
- `docs/` 目录下所有现存文档（包括 md、txt、pdf 说明、子目录）。
- 与 docs 关联的核心实现目录（按仓库实际）：例如 `backend/`、`storage/`、`frontend/`、`codes/` 等。

### 1.2 你必须输出的“事实”
- 列出 `docs/` 内的文档清单（含路径、标题/主题、是否过期/重复、与哪些模块相关）。
- 识别文档之间的重复、冲突、缺失（尤其是协议、存储结构、对话类型、settings、工具调用等）。

---

## 2. 整理策略（你要做的事）

### 2.1 先建立 docs 目录的新布局（建议，但可按实际调整）
请在 `docs/` 里形成清晰分区（可以保持轻量，重点是长期可维护）：

- `docs/00_overview/`：项目总览、快速开始、测试指南入口
- `docs/01_specs/`：**冻结规格**（协议/枚举/状态机/工具/存储布局/设置等的权威定义）
- `docs/02_guides/`：开发/测试操作指南（可变）
- `docs/03_reference/`：引用资料、链接、外部说明
- `docs/_archive/`：归档旧文档（按日期或主题分子目录）
- `docs/_index/`：统一索引（含 AI_INDEX 与 manifest）

> 重点：把“权威规格（spec）”与“操作指南（guide）”分开，避免互相污染。

### 2.2 旧文档整理规则
对 docs 下每个旧文件，做如下处理之一（必须能说明理由）：

- **保留原位**：仍然是权威且位置合理
- **移动到新分区**：例如从根目录移动到 `01_specs/` 或 `02_guides/`
- **归档到 `_archive/`**：内容过期但仍有参考价值
- **合并/去重**：多个文件重复时，合并为一个权威文件；其他文件归档并在索引中记录“已合并到 X”
- **标注弃用**：如果不能删除，则在文档头部加“DEPRECATED/过期”与替代文档路径

必须产出一份映射表：`旧路径 -> 新路径/状态`，并注明原因。

---

## 3. 新规范（AI_INDEX）必须产出什么

### 3.1 新文件：代码规范索引（必须）
- 路径建议：`docs/_index/AI_INDEX.md`
- 作用：给 Codex/人类开发者作为“每次开发任务的默认规范引用入口”。

#### AI_INDEX 的写作要求（必须）
1. **固定章节编号**（用于后续局部引用，不要经常改动编号）
2. 每个章节包含 3 个小块：
   - **Rules**：硬规则（短句、可执行、可检查）
   - **Checks**：如何验证（lint/test/脚本/人工清单）
   - **Scope**：影响范围（对应目录/模块/协议点）
3. 必须覆盖这些“高价值约束域”（按项目实际增删，但不得遗漏关键域）：
   - 仓库结构与分层边界（API/服务/领域/存储等）
   - 数据契约与协议冻结（返回 JSON、字段、枚举）
   - 对话类型/路由/上下文配置（如果项目已有）
   - Settings/配置系统（注册表、默认值、扩展点、校验）
   - Tool calls 协议（结构、allowlist、错误枚举）
   - 存储布局（storage 目录结构、campaign/turn log 等）
   - 冲突检测与重试（冲突类型、重试策略、落盘规则）
   - 状态机约束（状态 → 允许动作矩阵）
   - 测试与门禁（最小冒烟、lint、合同测试建议）
   - 变更流程（哪些变化必须更新哪些章节）

### 3.2 新文件：机器可读 manifest（强烈建议）
- 路径建议：`docs/_index/ai_index_manifest.json`
- 内容要求（最小可用即可）：
  - `version`
  - `sections`: 每个章节对应的监控路径列表（例如某章节受 `backend/api/routes/**` 影响）
  - `triggers`: 触发“必须更新 AI_INDEX”的规则（至少基于路径）
  - `sources_of_truth`: 列出权威规格文档路径（例如 `docs/01_specs/...`）

---

## 4. “每次都引用”的落地机制（至少完成最小版本）

你需要提供一个最小落地方案，使得后续每次让 Codex 改代码时都能引用规范：

### 4.1 必须新增一个“Codex 任务前缀”
- 路径建议：`docs/_index/CODEX_TASK_PREFIX.md`
- 内容：一段可复制粘贴的固定前缀，要求 Codex：
  - 开始前阅读 `docs/_index/AI_INDEX.md`
  - 修改受影响章节（如本次改动触发 triggers）
  - 输出变更文件清单与契约影响说明
  - 禁止越权重构/新增未定义协议字段

### 4.2 可选但推荐：最小门禁（只做路径级别即可）
若仓库已使用 CI / pre-commit，可添加一个极小的检查脚本或配置（允许你自行决定实现方式）：
- 当 diff 命中 manifest triggers（例如改了 `backend/api/routes/**` 或协议相关文件），但本次提交未修改 `docs/_index/AI_INDEX.md` 时，给出失败提示。
- 先做到“路径级”，不要上来就做 AST 解析。

> 如果当前仓库没有 CI，也可以只产出一个 `tools/check_docs_drift.py` 之类的脚本与用法说明，暂不接 CI。

---

## 5. 输出清单（你最终必须交付）

1. **docs 目录新布局**（实际文件移动/归档/合并完成）
2. `docs/_index/AI_INDEX.md`（新规范索引）
3. `docs/_index/ai_index_manifest.json`（可维护触发器与章节映射）
4. `docs/_index/CODEX_TASK_PREFIX.md`（每次开发固定前缀）
5. `docs/_index/DOCS_MIGRATION_REPORT.md`（迁移报告）包含：
   - 旧文档清单与新位置映射（表格）
   - 合并/弃用说明（指向权威文档）
   - 发现的冲突点/缺失点（列表）
   - 后续维护建议（非常简短，偏操作）

---

## 6. 执行步骤（请按顺序完成）

1. 扫描 `docs/`，生成“旧文档清单（含主题判断）”
2. 设计并创建新的 docs 目录布局（如上建议，可微调）
3. 逐文件处理：移动/归档/合并/标注弃用，并记录映射
4. 从“当前项目真实情况 + 归档后的权威规格”提炼 AI_INDEX
5. 写 manifest：章节 ↔ 路径；触发器（路径级）
6. 写 CODEX_TASK_PREFIX
7. 写迁移报告 DOCS_MIGRATION_REPORT
8. 进行一次自检：
   - AI_INDEX 是否能用“章节编号”定位？
   - 是否存在相互矛盾的规则？
   - 是否能回答：改了某目录时要更新哪一节？

---

## 7. 质量标准（验收）

- `docs/_index/AI_INDEX.md` 中每条硬规则都能在仓库中找到对应依据（代码结构或权威规格文件）
- 迁移报告可追溯：任何旧文档都能找到去向
- AI_INDEX 不是教程，而是“约束索引 + 检查点”
- 后续任何新功能开发，都能引用 CODEX_TASK_PREFIX 作为默认任务前缀

---

## 8. 注意事项

- 如果发现 docs 中存在“冻结规格缺失”但代码已实现的协议：请补齐到 `docs/01_specs/`，并在 AI_INDEX 中引用该 spec 文件作为 source-of-truth。
- 如果发现同一主题多个版本：必须选择一个作为权威（写明选择依据），其余归档并标注弃用。
